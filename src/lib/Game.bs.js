// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Random from "rescript/lib/es6/random.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";

function safeIndex(x) {
  var i = x[1];
  var length = x[0];
  if (i < 0) {
    return length - 1 | 0;
  } else if (i === length) {
    return 0;
  } else {
    return i;
  }
}

function safePoint(param, length) {
  return [
          safeIndex([
                length,
                param[0]
              ]),
          safeIndex([
                length,
                param[1]
              ])
        ];
}

function mapGrid(fn, grid) {
  return Belt_Array.mapWithIndex(grid, (function (y, row) {
                return Belt_Array.mapWithIndex(row, (function (x, tile) {
                              return Curry._3(fn, [
                                          y,
                                          x
                                        ], tile, grid);
                            }));
              }));
}

function makeBlankGrid(size$p) {
  return Belt_Array.make(size$p, Belt_Array.make(size$p, /* Dead */0));
}

function makeRandomGrid(size, seed) {
  Random.init(seed);
  return mapGrid((function (param, param$1, param$2) {
                if (Random.$$int(10) > 7) {
                  return /* Alive */1;
                } else {
                  return /* Dead */0;
                }
              }), makeBlankGrid(size));
}

function getTile(grid, point) {
  var match = safePoint(point, grid.length);
  return Caml_array.get(Caml_array.get(grid, match[0]), match[1]);
}

var offset = {
  hd: -1,
  tl: {
    hd: 0,
    tl: {
      hd: 1,
      tl: /* [] */0
    }
  }
};

function getNeighbours(grid, param) {
  var x = param[1];
  var y = param[0];
  return Belt_List.map(Belt_List.keep(Belt_List.flatten(Belt_List.map(offset, (function (y$p) {
                            return Belt_List.map(offset, (function (x$p) {
                                          return [
                                                  y + y$p | 0,
                                                  x + x$p | 0
                                                ];
                                        }));
                          }))), (function (p) {
                    return Caml_obj.caml_notequal(p, [
                                y,
                                x
                              ]);
                  })), (function (param) {
                return getTile(grid, param);
              }));
}

function countLivingNeighbours(grid, point) {
  return Belt_List.length(Belt_List.keep(getNeighbours(grid, point), (function (c) {
                    return c === /* Alive */1;
                  })));
}

function nextState(point, cellState, grid) {
  var neighbours = countLivingNeighbours(grid, point);
  if (cellState) {
    if (neighbours === 3 || neighbours === 2) {
      return /* Alive */1;
    } else {
      return /* Dead */0;
    }
  } else if (neighbours !== 3) {
    return /* Dead */0;
  } else {
    return /* Alive */1;
  }
}

function nextGeneration(param) {
  return mapGrid(nextState, param);
}

function toggleTile(grid, point) {
  var grid$p = Belt_Array.map(grid, (function (prim) {
          return prim.slice(0);
        }));
  var match = safePoint(point, grid.length);
  var x = match[1];
  var y = match[0];
  var tile = Caml_array.get(Caml_array.get(grid$p, y), x);
  Caml_array.set(Caml_array.get(grid$p, y), x, tile ? /* Dead */0 : /* Alive */1);
  return grid$p;
}

var L;

var A;

export {
  L ,
  A ,
  safeIndex ,
  safePoint ,
  mapGrid ,
  makeBlankGrid ,
  makeRandomGrid ,
  getTile ,
  offset ,
  getNeighbours ,
  countLivingNeighbours ,
  nextState ,
  nextGeneration ,
  toggleTile ,
  
}
/* No side effect */
